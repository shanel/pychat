#!/usr/bin/python

import sys
import os.path
import posix
import pwd
import termios
import curses
import curses.ascii
import threading
import Queue
import select
import socket
import time
import optparse
import stat

class HistoryQueue(object):
  def __init__(self):
    self.list = []
  def push(self,item):
    self.list.insert(0,item)
  def pop(self):
    return self.list.pop()
  def peek(self):
    return self.list[-1]
  def isEmpty(self):
    return len(self.list) == 0

class History(object):
  def __init__(self,limit,iterator=None):
    self.limit = limit
    self.items = []
    if iterator is not None:
      for val in iterator:
        self.record(val)
  def record(self,obj):
    self.items.append(obj)
    if len(self.items) > self.limit:
      self.items = self.items[1:]
  def __iter__(self):
    """go back in time"""
    for item in self.items:
      yield item
  def reversed(self):
    """per request by one bejnamin button"""
    for item in reversed(self.items):
      yield item
  def __getitem__(self,idx):
    """energize the flux capacitor"""
    return self.items[idx]
  def __len__(self):
    return len(self.items)
  def __getslice__(self,i,j):
    return self.items[i:j]
  def clear(self):
    """Burn the library at Alexandria, why don't you"""
    self.items = []

class KeyEvent(object):
  def __init__(self,ch):
    assert type(ch) is int
    self.ch = ch

class WinchEvent(object):
  pass

class RecvEvent(object):
  def __init__(self,s):
    self.s = s

parser = optparse.OptionParser()
parser.add_option('-n','--name',dest="name",type="string",
                  default=pwd.getpwuid(posix.getuid())[0],
                  help="use an alternate name")
parser.add_option('-c','--chattype',dest="chattype",type="string",
                  default="electionchat",#os.path.basename(sys.argv[0]),
                  help="Select chat type (electionchat, hoserchat, etc)")
parser.add_option('-s','--spartan',dest="spartan",
                  action="store_true",default=False,
                  help="Spartan mode. Don't display timestamps, etc.")

options,args = parser.parse_args()
if len(args) != 0:
  parser.error("Unable to parse all command line options")


progname = os.path.basename(sys.argv[0])
myhome = pwd.getpwuid(posix.getuid())[5]
sockdir  = '/tmp/.'+options.chattype
sockname = sockdir + '/'+options.name

def debug(s):
  return
  pipename = myhome+'/.pychatdbg'
  if not os.path.exists(pipename):
    return
  try:
    pipe = open(pipename,'w')
    if select.select([],[pipe],[],0)[1] is not []:
      print >> pipe, s
    pipe.close()
  except IOError:
    pass

stdscr = None
input_window = None
display_window = None
status_bar = None
screen_width  = 0
need_window_regeneration = False

buf           = ""
point         = 0
mark          = None
kill_ring     = HistoryQueue()
display_index = 0

received = History(1000)

history = []
max_history = 10
history_index = 0


events = Queue.Queue(-1)

VDSUSP = None
import platform
if platform.system() == 'Darwin':
  #mac
  VDSUSP = 11
  _POSIX_VDISABLE = '\xFF'
elif platform.system() == 'SunOS':
  VDSUSP = 11
  _POSIX_VDISABLE = '\x00'
elif platform.system() == 'Linux':
  #no DSUSP
  _POSIX_VDISABLE = '\x00'
else:
  #Guess
  _POSIX_VDISABLE = '\xFF'

quitting = False

ready_semaphore = threading.Semaphore(0)

def inform(s):
  add_to_display('pychat: %s' % s)

def keyboard_read_loop():
  while not quitting:
    try:
      if len(select.select([sys.stdin],[],[],.1)[0]) == 1:
        key = read_key()
        if key is not None:
          #only if we get a valid char. Ignore weird escape sequences
          events.put(KeyEvent(key))
    except select.error, e:
      pass

def read_key():
  key = ord(sys.stdin.read(1))
  if key==27: #escape
    key = ord(sys.stdin.read(1))
    nextkey = ord(sys.stdin.read(1))
    if key != 91 or nextkey == -1:
      return None #this sequence is stupid!
    nextkey = chr(nextkey) #let's use symbolic chars
    if nextkey == 'A':
      key = curses.KEY_UP
    elif nextkey == 'B':
      key = curses.KEY_DOWN
    elif nextkey == 'C':
      key = curses.KEY_RIGHT
    elif nextkey == 'D':
      key = curses.KEY_LEFT
    elif nextkey == 'F':
      key = curses.KEY_END
    elif nextkey == 'G':
      key = curses.KEY_NPAGE
    elif nextkey == 'H':
      key = curses.KEY_HOME
    elif nextkey == 'I':
      key = curses.KEY_PPAGE
    elif nextkey == 'L':
      key = curses.KEY_IC
    else:
      return None # man, screw this character
  return key

def winch_listen_loop():
  """Can't put the event in the queue from the signal handler, 
unfortunately, so this is a kludge"""
  global need_window_regeneration
  import time
  while not quitting:
    time.sleep(.2)
    if need_window_regeneration:
      events.put(WinchEvent())
      need_window_regeneration = False

def event_handle_loop():
  global quitting
  s = None
  while not quitting:
    e = events.get()
    if isinstance(e,WinchEvent):
      regenerate_windows()
      refresh_input_window()
    if isinstance(e,RecvEvent):
      add_to_display(e.s)
      move_cursor_to_point()
      input_window.refresh()
    if isinstance(e,KeyEvent):
      s = handle_key(e.ch)
      if s is not None:
        if len(s) == 0:
          inform("Gimme something to work with here!")
        elif s[0] == '/':
          handle_command(s)
        else:
          send_to_all("<%s> %s" % (options.name,s))
      refresh_input_window()
  quitting = True

def handle_command(cmdstr):
  command = cmdstr[1:cmdstr.index(' ')] if ' ' in cmdstr else cmdstr[1:]
  argstr  = cmdstr[cmdstr.index(' '):].strip() if ' ' in cmdstr else ''
  commands = {
    'quit'    : do_quit,
    'me'      : do_action,
    'msg'     : do_msg,
    'm'       : do_msg,
    'pipe'    : do_pipe,
    'we'      : do_we,
  }
  if command in commands:
    commands[command](argstr)
  else:
    inform('Unknown command "%s"' % command)

def do_quit(argstr):
  global quitting
  send_to_all('## %s left the chat (%s).' % (options.name,argstr))
  quitting = True

def do_action(argstr):
  send_to_all('(*) %s %s' % (options.name,argstr))

def do_msg(argstr):
  tokens = argstr.split()
  if len(tokens) < 2:
    inform("Need recipient list and message")
    return
  recipients = tokens[0].split(',')
  message = argstr[argstr.index(' '):].strip()
  any_found = False
  for recipient in recipients:
    if send_to_one(recipient,'%%%s->%s%% %s\n' %(options.name,tokens[0],message)):
      any_found = True
  if not any_found:
    inform("Need recipient list")
  else:
    send_to_one(options.name,'%%%s->%s%% %s\n' %(options.name,tokens[0],message))

def do_pipe(argstr):
  import subprocess
  pipeline = subprocess.Popen(argstr,shell=True,stdout=subprocess.PIPE)
  for line in pipeline.stdout:
    send_to_all('<%s> %s'%(options.name,line))

def do_we(argstr):
  people = []
  for filename in os.listdir(sockdir):
    stat_result = os.stat(os.path.join(sockdir,filename))
    if not stat.S_ISSOCK(stat_result.st_mode):
      continue
    people.append(filename)
  msg = '(*) '
  for person in people[:-1]:
    msg += person +', '
  msg += 'and ' + people[-1]
  msg += ' '+argstr
  send_to_all(msg)
  
def receive_loop():
  server_sock = socket.socket(socket.AF_UNIX,socket.SOCK_STREAM)
  server_sock.bind(sockname)
  server_sock.listen(100)
  server_sock.setblocking(0)
  ready_semaphore.release()
  while not quitting:
    try:
      conn,addr = server_sock.accept()
    except socket.error, e:
      time.sleep(.1)
      continue
    for line in conn.makefile():
      if line[-1] == '\n':
        line = line[:-1]
      if not options.spartan:
        line = time.strftime("[%H:%M] ")+line
      events.put(RecvEvent(line))
    conn.close()
  if os.path.exists(sockname):
    os.unlink(sockname)

def send_to_all(s):
  if s[-1] != '\n':
    s += '\n'
  for filename in os.listdir(sockdir):
    stat_result = os.stat(os.path.join(sockdir,filename))
    if not stat.S_ISSOCK(stat_result.st_mode):
      continue
    try:
      sock = socket.socket(socket.AF_UNIX,socket.SOCK_STREAM)
      sock.connect(os.path.join(sockdir,filename))
      sock.send(s)
      sock.close()
    except socket.error, e:
      inform("failed to send message %s to %s: %s" % (s,filename,e))

def send_to_one(user,s):
  path = os.path.join(sockdir,user)
  if not (os.path.exists(path) and stat.S_ISSOCK(os.stat(path).st_mode)):
    inform("%s isn't here" % user)
    return False
  try:
    sock = socket.socket(socket.AF_UNIX,socket.SOCK_STREAM)
    sock.connect(path)
    sock.send(s)
    sock.close()
  except socket.error, e:
    inform("failed to send message %s to %s" % (s,user))
    return False
  return True

def main():
  global need_window_regeneration,quitting,options
  import time
  import signal
  signal.signal(signal.SIGWINCH,winch_handler)
  signal.signal(signal.SIGTERM,term_handler)
  if not os.path.exists(sockdir):
    os.mkdir(sockdir)
  keyboard_thread = threading.Thread(target=keyboard_read_loop)
  keyboard_thread.start()
  winch_listener_thread = threading.Thread(target=winch_listen_loop)
  winch_listener_thread.start()
  event_handling_thread = threading.Thread(target=event_handle_loop)
  event_handling_thread.start()
  receiver_thread = threading.Thread(target=receive_loop)
  receiver_thread.start()
  #wait for receiver thread to create our socket so we see the following output
  ready_semaphore.acquire()
  inform('joining %s as "%s"' % (options.chattype,options.name))
  send_to_all('## %s joined the chat.' % options.name)
  while not quitting:
    time.sleep(.1)
  keyboard_thread.join()
  winch_listener_thread.join()
  event_handling_thread.join()
  keyboard_thread.join()
  receiver_thread.join()
  curses_shutdown()

def add_to_display(s):
  """add a string to the display window"""
  received.record(s)
  refresh_display_window()

def refresh_input_window():
  global display_index
  if point < display_index:
    #need to move left
    while point < display_index:
      display_index -= screen_width / 4 * 3
    if display_index < 0:
      #too tired to figure out if this can ever happen
      display_index = 0
  if point > display_index + screen_width - 1:
    #need to move right
    while point > display_index + screen_width - 1:
      display_index += screen_width / 4 * 3
  end_index = min(display_index + screen_width - 1,len(buf))
  to_display = buf[display_index:end_index]
  input_window.addstr(0,0,to_display)
  input_window.clrtoeol()
  move_cursor_to_point()
  input_window.refresh()

def refresh_display_window():
  display_window.clear()
  maxy,maxx = display_window.getmaxyx()
  if len(received) > maxy:
    selection = received[-maxy:]
  else:
    selection = received
  for thing in selection:
    display_window.scroll()
    display_window.addstr(maxy-1,0,thing)
  display_window.refresh()

def move_cursor_to_point():
  #how much are we missing?
  input_window.move(0,point - display_index)

def handle_key(key):
  global buf,point,mark
  s = None
  if key in [13,10,curses.KEY_ENTER]: #\r,\n,Enter
    s = buf
    buf = ""
    point = mark = 0
  elif key in [0x08,0x7F,curses.KEY_BACKSPACE]: # ^H, delete, backspace
    if point > 0:
      point-=1
      buf = buf[:point] + buf[point+1:]
      mark = None
    else:
      curses.beep()
  elif key in [0x04,curses.KEY_DC]: #^D or DEL
    if point < len(buf):
      buf = buf[:point] + buf[point+1:]
      mark = None
    else:
      curses.beep()
  elif key in [0x06,curses.KEY_RIGHT]: #^B or right
    if point < len(buf):
      point+=1
    else:
      curses.beep()
  elif key in [0x02,curses.KEY_LEFT]: #^F or left
    if point > 0:
      point-=1
    else:
      curses.beep()
  elif key in [0x0]: # ^  (i.e., ctrl+space: drop mark)
    mark = point
  elif key in [0x17]: # ^w
    if mark is None or point == mark:
      pass
    else:
      low = min(point,mark)
      high = max(point,mark)
      region = buf[low:high]
      kill_ring.push(region)
      buf = buf[:low]+buf[high:]
      mark = None
      point = low
  elif key in [ord(curses.ascii.ctrl('y'))]: #^y :yank
    if kill_ring.isEmpty():
      curses.beep()
    else:
      yanked = kill_ring.peek()
      buf = buf[:point] + yanked + buf[point:]
      point += len(yanked)
  elif key in [ord(curses.ascii.ctrl('k'))]: # kill to end of line
    mark = None
    kill_ring.push(buf[point:])
    buf = buf[:point]
  elif key in [ord(curses.ascii.ctrl('p')),curses.KEY_UP]: # prev line
    curses.beep()
  elif key in [ord(curses.ascii.ctrl('n')),curses.KEY_DOWN]: # next line
    curses.beep()
  elif key in [ord(curses.ascii.ctrl('a')),curses.KEY_HOME,curses.KEY_FIND]:
    point = 0
  elif key in [ord(curses.ascii.ctrl('e')),curses.KEY_END]:
    point = len(buf)
  else: #something else
    if key < 32 or key > 126:
      return
    mark = None
    buf = buf[:point] + chr(key)+ buf[point:]
    point += 1
  return s

def winch_handler(signum,frame):
  global need_window_regeneration
  need_window_regeneration = True

def term_handler(signum,frame):
  send_to_all('## %s left the chat (caught SIGTERM).' % options.name)
  sys.exit(1)

def generate_windows():
  global display_window,input_window,status_bar,screen_width
  maxy,maxx = stdscr.getmaxyx()
  screen_width = maxx
  
  display_window = stdscr.subwin(maxy-2,maxx,0,0)
  display_window.idlok(1)
  display_window.scrollok(True)
  display_window.leaveok(1)
  display_window.refresh()
  
  status_bar = stdscr.subwin(1,maxx,maxy-2,0)
  status_bar.attron(curses.A_REVERSE)
  status_bar.hline(0,0,'-',maxx)
  status_bar.refresh()
  
  input_window   = stdscr.subwin(1,maxx,maxy-1,0)
  input_window.nodelay(True)
  input_window.clear()
  input_window.refresh()

def regenerate_windows():
  global display_window,input_window,status_bar,screen_width
  import fcntl
  import struct
  s = struct.pack("HHHH",0,0,0,0)
  x = fcntl.ioctl(sys.stdout.fileno(),termios.TIOCGWINSZ,s)
  rows,cols,pixhi,pixwide = struct.unpack('HHHH',x)
  curses.resizeterm(rows,cols)
  maxy,maxx = stdscr.getmaxyx()
  screen_width = maxx
  
  display_window.resize(maxy-2,maxx)
  display_window.refresh()
  
  status_bar.mvwin(maxy-2,0)
  status_bar.hline(0,0,'-',maxx)
  status_bar.refresh()
  
  input_window.mvwin(maxy-1,0)
  input_window.resize(1,maxx)
  input_window.clear()
  input_window.refresh()
  
  refresh_display_window()


def curses_startup():
  global stdscr,display_window,input_window,input_box,screen_width
  new = termios.tcgetattr(sys.stdin)
  if VDSUSP is not None:
    new[-1][VDSUSP] = _POSIX_VDISABLE
  new[-1][termios.VSTOP] = _POSIX_VDISABLE
  new[-1][termios.VINTR] = _POSIX_VDISABLE
  termios.tcsetattr(sys.stdin,termios.TCSANOW,new)
  stdscr = curses.initscr()
  curses.noecho()
  curses.cbreak()
  stdscr.keypad(1)
  generate_windows()

def curses_shutdown():
  curses.nocbreak()
  stdscr.keypad(0)
  curses.echo()
  curses.endwin()

if __name__ == '__main__':
  if os.path.exists(sockname):
    print >> sys.stderr, "Can't start pychat: socket %s exists" % sockname
    print >> sys.stderr, "(You probably have pychat or hoserchat running; kill them)"
    sys.exit(1)
  try:
    old = termios.tcgetattr(sys.stdin)
    curses_startup()
    main()
  finally:
    termios.tcsetattr(sys.stdin,termios.TCSANOW,old)
    curses_shutdown()
    quitting = True
    if os.path.exists(sockname):
      os.unlink(sockname)
